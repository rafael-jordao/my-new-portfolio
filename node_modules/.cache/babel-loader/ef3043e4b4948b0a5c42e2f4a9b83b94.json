{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@jridgewell/sourcemap-codec'), require('@jridgewell/resolve-uri')) : typeof define === 'function' && define.amd ? define(['exports', '@jridgewell/sourcemap-codec', '@jridgewell/resolve-uri'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.traceMapping = {}, global.sourcemapCodec, global.resolveURI));\n})(this, function (exports, sourcemapCodec, resolveUri) {\n  'use strict';\n\n  function _interopDefaultLegacy(e) {\n    return e && typeof e === 'object' && 'default' in e ? e : {\n      'default': e\n    };\n  }\n\n  var resolveUri__default = /*#__PURE__*/_interopDefaultLegacy(resolveUri);\n\n  function resolve(input, base) {\n    // The base is always treated as a directory, if it's not empty.\n    // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n    // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n    if (base && !base.endsWith('/')) base += '/';\n    return resolveUri__default[\"default\"](input, base);\n  }\n  /**\n   * Removes everything after the last \"/\", but leaves the slash.\n   */\n\n\n  function stripFilename(path) {\n    if (!path) return '';\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n  }\n\n  function maybeSort(mappings, owned) {\n    const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n    if (unsortedIndex === mappings.length) return mappings; // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n    // not, we do not want to modify the consumer's input array.\n\n    if (!owned) mappings = mappings.slice();\n\n    for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n      mappings[i] = sortSegments(mappings[i], owned);\n    }\n\n    return mappings;\n  }\n\n  function nextUnsortedSegmentLine(mappings, start) {\n    for (let i = start; i < mappings.length; i++) {\n      if (!isSorted(mappings[i])) return i;\n    }\n\n    return mappings.length;\n  }\n\n  function isSorted(line) {\n    for (let j = 1; j < line.length; j++) {\n      if (line[j][0] < line[j - 1][0]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function sortSegments(line, owned) {\n    if (!owned) line = line.slice();\n    return line.sort(sortComparator);\n  }\n\n  function sortComparator(a, b) {\n    return a[0] - b[0];\n  }\n  /**\n   * A binary search implementation that returns the index if a match is found.\n   * If no match is found, then the left-index (the index associated with the item that comes just\n   * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n   * the next index:\n   *\n   * ```js\n   * const array = [1, 3];\n   * const needle = 2;\n   * const index = binarySearch(array, needle, (item, needle) => item - needle);\n   *\n   * assert.equal(index, 0);\n   * array.splice(index + 1, 0, needle);\n   * assert.deepEqual(array, [1, 2, 3]);\n   * ```\n   */\n\n\n  function binarySearch(haystack, needle, low, high) {\n    while (low <= high) {\n      const mid = low + (high - low >> 1);\n      const cmp = haystack[mid][0] - needle;\n\n      if (cmp === 0) {\n        return mid;\n      }\n\n      if (cmp < 0) {\n        low = mid + 1;\n      } else {\n        high = mid - 1;\n      }\n    }\n\n    return low - 1;\n  }\n\n  function memoizedState() {\n    return {\n      lastKey: -1,\n      lastNeedle: -1,\n      lastIndex: -1\n    };\n  }\n  /**\n   * This overly complicated beast is just to record the last tested line/column and the resulting\n   * index, allowing us to skip a few tests if mappings are monotonically increasing.\n   */\n\n\n  function memoizedBinarySearch(haystack, needle, state, key) {\n    const {\n      lastKey,\n      lastNeedle,\n      lastIndex\n    } = state;\n    let low = 0;\n    let high = haystack.length - 1;\n\n    if (key === lastKey) {\n      if (needle === lastNeedle) {\n        return lastIndex;\n      }\n\n      if (needle >= lastNeedle) {\n        // lastIndex may be -1 if the previous needle was not found.\n        low = Math.max(lastIndex, 0);\n      } else {\n        high = lastIndex;\n      }\n    }\n\n    state.lastKey = key;\n    state.lastNeedle = needle;\n    return state.lastIndex = binarySearch(haystack, needle, low, high);\n  }\n\n  const INVALID_MAPPING = Object.freeze({\n    source: null,\n    line: null,\n    column: null,\n    name: null\n  });\n  /**\n   * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n   */\n\n  exports.encodedMappings = void 0;\n  /**\n   * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n   */\n\n  exports.decodedMappings = void 0;\n  /**\n   * A low-level API to find the segment associated with a generated line/column (think, from a\n   * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n   */\n\n  exports.traceSegment = void 0;\n  /**\n   * A higher-level API to find the source/line/column associated with a generated line/column\n   * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n   * `source-map` library.\n   */\n\n  exports.originalPositionFor = void 0;\n  /**\n   * Iterates each mapping in generated position order.\n   */\n\n  exports.eachMapping = void 0;\n  /**\n   * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n   * maps.\n   */\n\n  exports.presortedDecodedMap = void 0;\n\n  class TraceMap {\n    constructor(map, mapUrl) {\n      this._binarySearchMemo = memoizedState();\n      const isString = typeof map === 'string';\n      const parsed = isString ? JSON.parse(map) : map;\n      const {\n        version,\n        file,\n        names,\n        sourceRoot,\n        sources,\n        sourcesContent\n      } = parsed;\n      this.version = version;\n      this.file = file;\n      this.names = names;\n      this.sourceRoot = sourceRoot;\n      this.sources = sources;\n      this.sourcesContent = sourcesContent;\n\n      if (sourceRoot || mapUrl) {\n        const from = resolve(sourceRoot || '', stripFilename(mapUrl));\n        this.resolvedSources = sources.map(s => resolve(s || '', from));\n      } else {\n        this.resolvedSources = sources.map(s => s || '');\n      }\n\n      const {\n        mappings\n      } = parsed;\n\n      if (typeof mappings === 'string') {\n        this._encoded = mappings;\n        this._decoded = sourcemapCodec.decode(mappings);\n      } else {\n        this._encoded = undefined;\n        this._decoded = maybeSort(mappings, isString);\n      }\n    }\n\n  }\n\n  (() => {\n    exports.encodedMappings = map => {\n      var _a;\n\n      return (_a = map._encoded) !== null && _a !== void 0 ? _a : map._encoded = sourcemapCodec.encode(map._decoded);\n    };\n\n    exports.decodedMappings = map => {\n      return map._decoded;\n    };\n\n    exports.traceSegment = (map, line, column) => {\n      const decoded = map._decoded; // It's common for parent source maps to have pointers to lines that have no\n      // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n\n      if (line >= decoded.length) return null;\n      const segments = decoded[line];\n      const index = memoizedBinarySearch(segments, column, map._binarySearchMemo, line); // we come before any mapped segment\n\n      if (index < 0) return null;\n      return segments[index];\n    };\n\n    exports.originalPositionFor = (map, _ref) => {\n      let {\n        line,\n        column\n      } = _ref;\n      if (line < 1) throw new Error('`line` must be greater than 0 (lines start at line 1)');\n\n      if (column < 0) {\n        throw new Error('`column` must be greater than or equal to 0 (columns start at column 0)');\n      }\n\n      const segment = exports.traceSegment(map, line - 1, column);\n      if (segment == null) return INVALID_MAPPING;\n      if (segment.length == 1) return INVALID_MAPPING;\n      const {\n        names,\n        resolvedSources\n      } = map;\n      return {\n        source: resolvedSources[segment[1]],\n        line: segment[2] + 1,\n        column: segment[3],\n        name: segment.length === 5 ? names[segment[4]] : null\n      };\n    };\n\n    exports.eachMapping = (map, cb) => {\n      const decoded = map._decoded;\n      const {\n        names,\n        resolvedSources\n      } = map;\n\n      for (let i = 0; i < decoded.length; i++) {\n        const line = decoded[i];\n\n        for (let j = 0; j < line.length; j++) {\n          const seg = line[j];\n          const generatedLine = i + 1;\n          const generatedColumn = seg[0];\n          let source = null;\n          let originalLine = null;\n          let originalColumn = null;\n          let name = null;\n\n          if (seg.length !== 1) {\n            source = resolvedSources[seg[1]];\n            originalLine = seg[2] + 1;\n            originalColumn = seg[3];\n          }\n\n          if (seg.length === 5) name = names[seg[4]];\n          cb({\n            generatedLine,\n            generatedColumn,\n            source,\n            originalLine,\n            originalColumn,\n            name\n          });\n        }\n      }\n    };\n\n    exports.presortedDecodedMap = (map, mapUrl) => {\n      const clone = Object.assign({}, map);\n      clone.mappings = [];\n      const tracer = new TraceMap(clone, mapUrl);\n      tracer._decoded = map.mappings;\n      return tracer;\n    };\n  })();\n\n  exports.TraceMap = TraceMap;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"mappings":"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","names":["resolve","input","base","endsWith","resolveUri","stripFilename","path","index","lastIndexOf","slice","maybeSort","mappings","owned","unsortedIndex","nextUnsortedSegmentLine","length","i","sortSegments","start","isSorted","line","j","sort","sortComparator","a","b","binarySearch","haystack","needle","low","high","mid","cmp","memoizedState","lastKey","lastNeedle","lastIndex","memoizedBinarySearch","state","key","Math","max","INVALID_MAPPING","Object","freeze","source","column","name","encodedMappings","decodedMappings","traceSegment","originalPositionFor","eachMapping","presortedDecodedMap","TraceMap","constructor","map","mapUrl","isString","parsed","JSON","parse","version","file","names","sourceRoot","sources","sourcesContent","from","resolvedSources","s","_encoded","_decoded","decode","undefined","_a","encode","decoded","segments","_binarySearchMemo","Error","segment","cb","seg","generatedLine","generatedColumn","originalLine","originalColumn","clone","assign","tracer"],"sources":["../../src/resolve.ts","../../src/strip-filename.ts","../../src/sort.ts","../../src/binary-search.ts","../../src/trace-mapping.ts"],"sourcesContent":[null,null,null,null,null]},"metadata":{},"sourceType":"script"}