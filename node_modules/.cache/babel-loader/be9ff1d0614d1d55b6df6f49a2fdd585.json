{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._containerInsert = _containerInsert;\nexports._containerInsertAfter = _containerInsertAfter;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._verifyNodeList = _verifyNodeList;\nexports.hoist = hoist;\nexports.insertAfter = insertAfter;\nexports.insertBefore = insertBefore;\nexports.pushContainer = pushContainer;\nexports.unshiftContainer = unshiftContainer;\nexports.updateSiblingKeys = updateSiblingKeys;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = require(\"./lib/hoister\");\n\nvar _index = require(\"./index\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  arrowFunctionExpression,\n  assertExpression,\n  assignmentExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  isAssignmentExpression,\n  isCallExpression,\n  isExpression,\n  isIdentifier,\n  isSequenceExpression,\n  isSuper,\n  thisExpression\n} = _t;\n\nfunction insertBefore(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nconst last = arr => arr[arr.length - 1];\n\nfunction isHiddenInSequenceExpression(path) {\n  return isSequenceExpression(path.parent) && (last(path.parent.expressions) !== path.node || isHiddenInSequenceExpression(path.parentPath));\n}\n\nfunction isAlmostConstantAssignment(node, scope) {\n  if (!isAssignmentExpression(node) || !isIdentifier(node.left)) {\n    return false;\n  }\n\n  const blockScope = scope.getBlockParent();\n  return blockScope.hasOwnBinding(node.left.name) && blockScope.getOwnBinding(node.left.name).constantViolations.length <= 1;\n}\n\nfunction insertAfter(nodes_) {\n  this._assertUnremoved();\n\n  if (this.isSequenceExpression()) {\n    return last(this.get(\"expressions\")).insertAfter(nodes_);\n  }\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return isExpression(node) ? expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      const node = this.node;\n      let {\n        scope\n      } = this;\n\n      if (scope.path.isPattern()) {\n        assertExpression(node);\n        this.replaceWith(callExpression(arrowFunctionExpression([], node), []));\n        this.get(\"callee.body\").insertAfter(nodes);\n        return [this];\n      }\n\n      if (isHiddenInSequenceExpression(this)) {\n        nodes.unshift(node);\n      } else if (isCallExpression(node) && isSuper(node.callee)) {\n        nodes.unshift(node);\n        nodes.push(thisExpression());\n      } else if (isAlmostConstantAssignment(node, scope)) {\n        nodes.unshift(node);\n        nodes.push(cloneNode(node.left));\n      } else if (scope.isPure(node, true)) {\n        nodes.push(node);\n      } else {\n        if (parentPath.isMethod({\n          computed: true,\n          key: node\n        })) {\n          scope = scope.parent;\n        }\n\n        const temp = scope.generateDeclaredUidIdentifier();\n        nodes.unshift(expressionStatement(assignmentExpression(\"=\", cloneNode(temp), node)));\n        nodes.push(expressionStatement(cloneNode(temp)));\n      }\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  const paths = _cache.path.get(this.parent);\n\n  for (const [, path] of paths) {\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey,\n    key: 0\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  const verifiedNodes = this._verifyNodeList(nodes);\n\n  const container = this.node[listKey];\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey,\n    key: container.length\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(verifiedNodes);\n}\n\nfunction hoist() {\n  let scope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.scope;\n  const hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}","map":{"version":3,"sources":["/Users/rafaeljordao/Documents/my-portfolio/node_modules/@babel/traverse/lib/path/modification.js"],"names":["Object","defineProperty","exports","value","_containerInsert","_containerInsertAfter","_containerInsertBefore","_verifyNodeList","hoist","insertAfter","insertBefore","pushContainer","unshiftContainer","updateSiblingKeys","_cache","require","_hoister","_index","_t","arrowFunctionExpression","assertExpression","assignmentExpression","blockStatement","callExpression","cloneNode","expressionStatement","isAssignmentExpression","isCallExpression","isExpression","isIdentifier","isSequenceExpression","isSuper","thisExpression","nodes_","_assertUnremoved","nodes","parentPath","isExpressionStatement","isLabeledStatement","isExportNamedDeclaration","isExportDefaultDeclaration","isDeclaration","isNodeType","isJSXElement","isForStatement","key","node","push","replaceExpressionWithStatements","Array","isArray","container","isStatementOrBlock","shouldInsertCurrentNode","expression","replaceWith","Error","from","length","paths","splice","i","to","path","getSibling","context","queue","pushContext","contexts","_getQueueContexts","setScope","debug","maybeQueue","last","arr","isHiddenInSequenceExpression","parent","expressions","isAlmostConstantAssignment","scope","left","blockScope","getBlockParent","hasOwnBinding","name","getOwnBinding","constantViolations","get","map","isPattern","unshift","callee","isPure","isMethod","computed","temp","generateDeclaredUidIdentifier","fromIndex","incrementBy","msg","type","default","listKey","setContext","verifiedNodes","replaceWithMultiple","hoister","run"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._containerInsert = _containerInsert;\nexports._containerInsertAfter = _containerInsertAfter;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._verifyNodeList = _verifyNodeList;\nexports.hoist = hoist;\nexports.insertAfter = insertAfter;\nexports.insertBefore = insertBefore;\nexports.pushContainer = pushContainer;\nexports.unshiftContainer = unshiftContainer;\nexports.updateSiblingKeys = updateSiblingKeys;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = require(\"./lib/hoister\");\n\nvar _index = require(\"./index\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  arrowFunctionExpression,\n  assertExpression,\n  assignmentExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  isAssignmentExpression,\n  isCallExpression,\n  isExpression,\n  isIdentifier,\n  isSequenceExpression,\n  isSuper,\n  thisExpression\n} = _t;\n\nfunction insertBefore(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nconst last = arr => arr[arr.length - 1];\n\nfunction isHiddenInSequenceExpression(path) {\n  return isSequenceExpression(path.parent) && (last(path.parent.expressions) !== path.node || isHiddenInSequenceExpression(path.parentPath));\n}\n\nfunction isAlmostConstantAssignment(node, scope) {\n  if (!isAssignmentExpression(node) || !isIdentifier(node.left)) {\n    return false;\n  }\n\n  const blockScope = scope.getBlockParent();\n  return blockScope.hasOwnBinding(node.left.name) && blockScope.getOwnBinding(node.left.name).constantViolations.length <= 1;\n}\n\nfunction insertAfter(nodes_) {\n  this._assertUnremoved();\n\n  if (this.isSequenceExpression()) {\n    return last(this.get(\"expressions\")).insertAfter(nodes_);\n  }\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return isExpression(node) ? expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      const node = this.node;\n      let {\n        scope\n      } = this;\n\n      if (scope.path.isPattern()) {\n        assertExpression(node);\n        this.replaceWith(callExpression(arrowFunctionExpression([], node), []));\n        this.get(\"callee.body\").insertAfter(nodes);\n        return [this];\n      }\n\n      if (isHiddenInSequenceExpression(this)) {\n        nodes.unshift(node);\n      } else if (isCallExpression(node) && isSuper(node.callee)) {\n        nodes.unshift(node);\n        nodes.push(thisExpression());\n      } else if (isAlmostConstantAssignment(node, scope)) {\n        nodes.unshift(node);\n        nodes.push(cloneNode(node.left));\n      } else if (scope.isPure(node, true)) {\n        nodes.push(node);\n      } else {\n        if (parentPath.isMethod({\n          computed: true,\n          key: node\n        })) {\n          scope = scope.parent;\n        }\n\n        const temp = scope.generateDeclaredUidIdentifier();\n        nodes.unshift(expressionStatement(assignmentExpression(\"=\", cloneNode(temp), node)));\n        nodes.push(expressionStatement(cloneNode(temp)));\n      }\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  const paths = _cache.path.get(this.parent);\n\n  for (const [, path] of paths) {\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey,\n    key: 0\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  const verifiedNodes = this._verifyNodeList(nodes);\n\n  const container = this.node[listKey];\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey,\n    key: container.length\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(verifiedNodes);\n}\n\nfunction hoist(scope = this.scope) {\n  const hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}"]},"metadata":{},"sourceType":"script"}