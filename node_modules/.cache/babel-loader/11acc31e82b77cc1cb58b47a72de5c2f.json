{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\nexports.arrowFunctionToShadowed = arrowFunctionToShadowed;\nexports.ensureBlock = ensureBlock;\nexports.toComputedKey = toComputedKey;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\n\nvar _t = require(\"@babel/types\");\n\nvar _helperEnvironmentVisitor = require(\"@babel/helper-environment-visitor\");\n\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\n\nvar _visitors = require(\"../visitors\");\n\nconst {\n  arrowFunctionExpression,\n  assignmentExpression,\n  binaryExpression,\n  blockStatement,\n  callExpression,\n  conditionalExpression,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  jsxIdentifier,\n  logicalExpression,\n  LOGICAL_OPERATORS,\n  memberExpression,\n  metaProperty,\n  numericLiteral,\n  objectExpression,\n  restElement,\n  returnStatement,\n  sequenceExpression,\n  spreadElement,\n  stringLiteral,\n  super: _super,\n  thisExpression,\n  toExpression,\n  unaryExpression\n} = _t;\n\nfunction toComputedKey() {\n  let key;\n\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  if (!this.node.computed) {\n    if (isIdentifier(key)) key = stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nfunction ensureBlock() {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n\n  const statements = [];\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(expressionStatement(body.node));\n    }\n  }\n\n  this.node.body = blockStatement(statements);\n  const parentPath = this.get(stringPath);\n  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\n\nfunction arrowFunctionToShadowed() {\n  if (!this.isArrowFunctionExpression()) return;\n  this.arrowFunctionToExpression();\n}\n\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction arrowFunctionToExpression() {\n  let {\n    allowInsertArrow = true,\n    specCompliant = false,\n    noNewArrows = !specCompliant\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n\n  const {\n    thisBinding,\n    fnPath: fn\n  } = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow);\n  fn.ensureBlock();\n  fn.node.type = \"FunctionExpression\";\n\n  if (!noNewArrows) {\n    const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier(\"arrowCheckId\");\n\n    if (checkBinding) {\n      fn.parentPath.scope.push({\n        id: checkBinding,\n        init: objectExpression([])\n      });\n    }\n\n    fn.get(\"body\").unshiftContainer(\"body\", expressionStatement(callExpression(this.hub.addHelper(\"newArrowCheck\"), [thisExpression(), checkBinding ? identifier(checkBinding.name) : identifier(thisBinding)])));\n    fn.replaceWith(callExpression(memberExpression((0, _helperFunctionName.default)(this, true) || fn.node, identifier(\"bind\")), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));\n  }\n}\n\nconst getSuperCallsVisitor = (0, _visitors.merge)([{\n  CallExpression(child, _ref) {\n    let {\n      allSuperCalls\n    } = _ref;\n    if (!child.get(\"callee\").isSuper()) return;\n    allSuperCalls.push(child);\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nfunction hoistFunctionEnvironment(fnPath) {\n  let noNewArrows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  let allowInsertArrow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let arrowParent;\n  let thisEnvFn = fnPath.findParent(p => {\n    if (p.isArrowFunctionExpression()) {\n      var _arrowParent;\n\n      (_arrowParent = arrowParent) != null ? _arrowParent : arrowParent = p;\n      return false;\n    }\n\n    return p.isFunction() || p.isProgram() || p.isClassProperty({\n      static: false\n    }) || p.isClassPrivateProperty({\n      static: false\n    });\n  });\n  const inConstructor = thisEnvFn.isClassMethod({\n    kind: \"constructor\"\n  });\n\n  if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {\n    if (arrowParent) {\n      thisEnvFn = arrowParent;\n    } else if (allowInsertArrow) {\n      fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), []));\n      thisEnvFn = fnPath.get(\"callee\");\n      fnPath = thisEnvFn.get(\"body\");\n    } else {\n      throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n    }\n  }\n\n  const {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  } = getScopeInformation(fnPath);\n\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"Unable to handle nested super() usage in arrow\");\n    }\n\n    const allSuperCalls = [];\n    thisEnvFn.traverse(getSuperCallsVisitor, {\n      allSuperCalls\n    });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => {\n      const args = () => identifier(\"arguments\");\n\n      if (thisEnvFn.scope.path.isProgram()) {\n        return conditionalExpression(binaryExpression(\"===\", unaryExpression(\"typeof\", args()), stringLiteral(\"undefined\")), thisEnvFn.scope.buildUndefinedNode(), args());\n      } else {\n        return args();\n      }\n    });\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () => metaProperty(identifier(\"new\"), identifier(\"target\")));\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"Unable to handle nested super.prop usage\");\n    }\n\n    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n      const isAssignment = superProp.parentPath.isAssignmentExpression({\n        left: superProp.node\n      });\n      const isCall = superProp.parentPath.isCallExpression({\n        callee: superProp.node\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n      const args = [];\n\n      if (superProp.node.computed) {\n        args.push(superProp.get(\"property\").node);\n      }\n\n      if (isAssignment) {\n        const value = superProp.parentPath.node.right;\n        args.push(value);\n      }\n\n      const call = callExpression(identifier(superBinding), args);\n\n      if (isCall) {\n        superProp.parentPath.unshiftContainer(\"arguments\", thisExpression());\n        superProp.replaceWith(memberExpression(call, identifier(\"call\")));\n        thisPaths.push(superProp.parentPath.get(\"arguments.0\"));\n      } else if (isAssignment) {\n        superProp.parentPath.replaceWith(call);\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  let thisBinding;\n\n  if (thisPaths.length > 0 || !noNewArrows) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (!noNewArrows) thisBinding = null;\n    }\n  }\n\n  return {\n    thisBinding,\n    fnPath\n  };\n}\n\nfunction isLogicalOp(op) {\n  return LOGICAL_OPERATORS.includes(op);\n}\n\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    const assignmentPath = superProp.parentPath;\n    const op = assignmentPath.node.operator.slice(0, -1);\n    const value = assignmentPath.node.right;\n    const isLogicalAssignment = isLogicalOp(op);\n\n    if (superProp.node.computed) {\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      const object = superProp.node.object;\n      const property = superProp.node.property;\n      assignmentPath.get(\"left\").replaceWith(memberExpression(object, assignmentExpression(\"=\", tmp, property), true));\n      assignmentPath.get(\"right\").replaceWith(rightExpression(isLogicalAssignment ? \"=\" : op, memberExpression(object, identifier(tmp.name), true), value));\n    } else {\n      const object = superProp.node.object;\n      const property = superProp.node.property;\n      assignmentPath.get(\"left\").replaceWith(memberExpression(object, property));\n      assignmentPath.get(\"right\").replaceWith(rightExpression(isLogicalAssignment ? \"=\" : op, memberExpression(object, identifier(property.name)), value));\n    }\n\n    if (isLogicalAssignment) {\n      assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right));\n    } else {\n      assignmentPath.node.operator = \"=\";\n    }\n\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    const parts = [assignmentExpression(\"=\", tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression(\"=\", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(superProp.parentPath.node.operator[0], identifier(tmp.name), numericLiteral(1)))];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(sequenceExpression(parts));\n    const left = updateExpr.get(\"expressions.0.right\");\n    const right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n\n  return [superProp];\n\n  function rightExpression(op, left, right) {\n    if (op === \"=\") {\n      return assignmentExpression(\"=\", left, right);\n    } else {\n      return binaryExpression(op, left, right);\n    }\n  }\n}\n\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\n\nconst assignSuperThisVisitor = (0, _visitors.merge)([{\n  CallExpression(child, _ref2) {\n    let {\n      supers,\n      thisBinding\n    } = _ref2;\n    if (!child.get(\"callee\").isSuper()) return;\n    if (supers.has(child.node)) return;\n    supers.add(child.node);\n    child.replaceWithMultiple([child.node, assignmentExpression(\"=\", identifier(thisBinding), identifier(\"this\"))]);\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();\n    thisEnvFn.traverse(assignSuperThisVisitor, {\n      supers: new WeakSet(),\n      thisBinding\n    });\n  });\n}\n\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));\n  });\n}\n\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  const op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n    let fnBody;\n\n    if (propName) {\n      fnBody = memberExpression(_super(), identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = memberExpression(_super(), identifier(method.name), true);\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = assignmentExpression(\"=\", fnBody, identifier(valueIdent.name));\n    }\n\n    return arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(thisEnvFn, key, init) {\n  const cacheKey = \"binding:\" + key;\n  let data = thisEnvFn.getData(cacheKey);\n\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n\n  return data;\n}\n\nconst getScopeInformationVisitor = (0, _visitors.merge)([{\n  ThisExpression(child, _ref3) {\n    let {\n      thisPaths\n    } = _ref3;\n    thisPaths.push(child);\n  },\n\n  JSXIdentifier(child, _ref4) {\n    let {\n      thisPaths\n    } = _ref4;\n    if (child.node.name !== \"this\") return;\n\n    if (!child.parentPath.isJSXMemberExpression({\n      object: child.node\n    }) && !child.parentPath.isJSXOpeningElement({\n      name: child.node\n    })) {\n      return;\n    }\n\n    thisPaths.push(child);\n  },\n\n  CallExpression(child, _ref5) {\n    let {\n      superCalls\n    } = _ref5;\n    if (child.get(\"callee\").isSuper()) superCalls.push(child);\n  },\n\n  MemberExpression(child, _ref6) {\n    let {\n      superProps\n    } = _ref6;\n    if (child.get(\"object\").isSuper()) superProps.push(child);\n  },\n\n  Identifier(child, _ref7) {\n    let {\n      argumentsPaths\n    } = _ref7;\n    if (!child.isReferencedIdentifier({\n      name: \"arguments\"\n    })) return;\n    let curr = child.scope;\n\n    do {\n      if (curr.hasOwnBinding(\"arguments\")) {\n        curr.rename(\"arguments\");\n        return;\n      }\n\n      if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {\n        break;\n      }\n    } while (curr = curr.parent);\n\n    argumentsPaths.push(child);\n  },\n\n  MetaProperty(child, _ref8) {\n    let {\n      newTargetPaths\n    } = _ref8;\n    if (!child.get(\"meta\").isIdentifier({\n      name: \"new\"\n    })) return;\n    if (!child.get(\"property\").isIdentifier({\n      name: \"target\"\n    })) return;\n    newTargetPaths.push(child);\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nfunction getScopeInformation(fnPath) {\n  const thisPaths = [];\n  const argumentsPaths = [];\n  const newTargetPaths = [];\n  const superProps = [];\n  const superCalls = [];\n  fnPath.traverse(getScopeInformationVisitor, {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  });\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  };\n}","map":{"version":3,"sources":["/Users/rafaeljordao/Documents/my-portfolio/node_modules/@babel/traverse/lib/path/conversion.js"],"names":["Object","defineProperty","exports","value","arrowFunctionToExpression","arrowFunctionToShadowed","ensureBlock","toComputedKey","unwrapFunctionEnvironment","_t","require","_helperEnvironmentVisitor","_helperFunctionName","_visitors","arrowFunctionExpression","assignmentExpression","binaryExpression","blockStatement","callExpression","conditionalExpression","expressionStatement","identifier","isIdentifier","jsxIdentifier","logicalExpression","LOGICAL_OPERATORS","memberExpression","metaProperty","numericLiteral","objectExpression","restElement","returnStatement","sequenceExpression","spreadElement","stringLiteral","super","_super","thisExpression","toExpression","unaryExpression","key","isMemberExpression","node","property","isProperty","isMethod","ReferenceError","computed","name","body","get","bodyNode","Array","isArray","Error","isBlockStatement","statements","stringPath","listKey","isStatement","push","isFunction","parentPath","setup","isArrowFunctionExpression","isFunctionExpression","isFunctionDeclaration","buildCodeFrameError","hoistFunctionEnvironment","allowInsertArrow","specCompliant","noNewArrows","thisBinding","fnPath","fn","type","checkBinding","scope","generateUidIdentifier","id","init","unshiftContainer","hub","addHelper","replaceWith","default","getSuperCallsVisitor","merge","CallExpression","child","allSuperCalls","isSuper","arrowParent","thisEnvFn","findParent","p","_arrowParent","isProgram","isClassProperty","static","isClassPrivateProperty","inConstructor","isClassMethod","kind","thisPaths","argumentsPaths","newTargetPaths","superProps","superCalls","getScopeInformation","length","traverse","superBinding","getSuperBinding","forEach","superCall","callee","loc","argumentsBinding","getBinding","args","path","buildUndefinedNode","argumentsChild","argsRef","newTargetBinding","targetChild","targetRef","flatSuperProps","reduce","acc","superProp","concat","standardizeSuperProperty","isAssignment","isAssignmentExpression","left","isCall","isCallExpression","getSuperPropBinding","right","call","getThisBinding","hasSuperClass","thisChild","thisRef","isJSX","isLogicalOp","op","includes","operator","assignmentPath","slice","isLogicalAssignment","tmp","generateDeclaredUidIdentifier","object","rightExpression","isUpdateExpression","updateExpr","computedKey","parts","prefix","superClass","assignSuperThisVisitor","supers","has","add","replaceWithMultiple","WeakSet","argsBinding","propName","argsList","fnBody","method","unshift","valueIdent","cacheKey","data","getData","setData","getScopeInformationVisitor","ThisExpression","JSXIdentifier","isJSXMemberExpression","isJSXOpeningElement","MemberExpression","Identifier","isReferencedIdentifier","curr","hasOwnBinding","rename","parent","MetaProperty"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\nexports.arrowFunctionToShadowed = arrowFunctionToShadowed;\nexports.ensureBlock = ensureBlock;\nexports.toComputedKey = toComputedKey;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\n\nvar _t = require(\"@babel/types\");\n\nvar _helperEnvironmentVisitor = require(\"@babel/helper-environment-visitor\");\n\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\n\nvar _visitors = require(\"../visitors\");\n\nconst {\n  arrowFunctionExpression,\n  assignmentExpression,\n  binaryExpression,\n  blockStatement,\n  callExpression,\n  conditionalExpression,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  jsxIdentifier,\n  logicalExpression,\n  LOGICAL_OPERATORS,\n  memberExpression,\n  metaProperty,\n  numericLiteral,\n  objectExpression,\n  restElement,\n  returnStatement,\n  sequenceExpression,\n  spreadElement,\n  stringLiteral,\n  super: _super,\n  thisExpression,\n  toExpression,\n  unaryExpression\n} = _t;\n\nfunction toComputedKey() {\n  let key;\n\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  if (!this.node.computed) {\n    if (isIdentifier(key)) key = stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nfunction ensureBlock() {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n\n  const statements = [];\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(expressionStatement(body.node));\n    }\n  }\n\n  this.node.body = blockStatement(statements);\n  const parentPath = this.get(stringPath);\n  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\n\nfunction arrowFunctionToShadowed() {\n  if (!this.isArrowFunctionExpression()) return;\n  this.arrowFunctionToExpression();\n}\n\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction arrowFunctionToExpression({\n  allowInsertArrow = true,\n  specCompliant = false,\n  noNewArrows = !specCompliant\n} = {}) {\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n\n  const {\n    thisBinding,\n    fnPath: fn\n  } = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow);\n  fn.ensureBlock();\n  fn.node.type = \"FunctionExpression\";\n\n  if (!noNewArrows) {\n    const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier(\"arrowCheckId\");\n\n    if (checkBinding) {\n      fn.parentPath.scope.push({\n        id: checkBinding,\n        init: objectExpression([])\n      });\n    }\n\n    fn.get(\"body\").unshiftContainer(\"body\", expressionStatement(callExpression(this.hub.addHelper(\"newArrowCheck\"), [thisExpression(), checkBinding ? identifier(checkBinding.name) : identifier(thisBinding)])));\n    fn.replaceWith(callExpression(memberExpression((0, _helperFunctionName.default)(this, true) || fn.node, identifier(\"bind\")), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));\n  }\n}\n\nconst getSuperCallsVisitor = (0, _visitors.merge)([{\n  CallExpression(child, {\n    allSuperCalls\n  }) {\n    if (!child.get(\"callee\").isSuper()) return;\n    allSuperCalls.push(child);\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nfunction hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true) {\n  let arrowParent;\n  let thisEnvFn = fnPath.findParent(p => {\n    if (p.isArrowFunctionExpression()) {\n      var _arrowParent;\n\n      (_arrowParent = arrowParent) != null ? _arrowParent : arrowParent = p;\n      return false;\n    }\n\n    return p.isFunction() || p.isProgram() || p.isClassProperty({\n      static: false\n    }) || p.isClassPrivateProperty({\n      static: false\n    });\n  });\n  const inConstructor = thisEnvFn.isClassMethod({\n    kind: \"constructor\"\n  });\n\n  if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {\n    if (arrowParent) {\n      thisEnvFn = arrowParent;\n    } else if (allowInsertArrow) {\n      fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), []));\n      thisEnvFn = fnPath.get(\"callee\");\n      fnPath = thisEnvFn.get(\"body\");\n    } else {\n      throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n    }\n  }\n\n  const {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  } = getScopeInformation(fnPath);\n\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"Unable to handle nested super() usage in arrow\");\n    }\n\n    const allSuperCalls = [];\n    thisEnvFn.traverse(getSuperCallsVisitor, {\n      allSuperCalls\n    });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => {\n      const args = () => identifier(\"arguments\");\n\n      if (thisEnvFn.scope.path.isProgram()) {\n        return conditionalExpression(binaryExpression(\"===\", unaryExpression(\"typeof\", args()), stringLiteral(\"undefined\")), thisEnvFn.scope.buildUndefinedNode(), args());\n      } else {\n        return args();\n      }\n    });\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () => metaProperty(identifier(\"new\"), identifier(\"target\")));\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"Unable to handle nested super.prop usage\");\n    }\n\n    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n      const isAssignment = superProp.parentPath.isAssignmentExpression({\n        left: superProp.node\n      });\n      const isCall = superProp.parentPath.isCallExpression({\n        callee: superProp.node\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n      const args = [];\n\n      if (superProp.node.computed) {\n        args.push(superProp.get(\"property\").node);\n      }\n\n      if (isAssignment) {\n        const value = superProp.parentPath.node.right;\n        args.push(value);\n      }\n\n      const call = callExpression(identifier(superBinding), args);\n\n      if (isCall) {\n        superProp.parentPath.unshiftContainer(\"arguments\", thisExpression());\n        superProp.replaceWith(memberExpression(call, identifier(\"call\")));\n        thisPaths.push(superProp.parentPath.get(\"arguments.0\"));\n      } else if (isAssignment) {\n        superProp.parentPath.replaceWith(call);\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  let thisBinding;\n\n  if (thisPaths.length > 0 || !noNewArrows) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (!noNewArrows) thisBinding = null;\n    }\n  }\n\n  return {\n    thisBinding,\n    fnPath\n  };\n}\n\nfunction isLogicalOp(op) {\n  return LOGICAL_OPERATORS.includes(op);\n}\n\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    const assignmentPath = superProp.parentPath;\n    const op = assignmentPath.node.operator.slice(0, -1);\n    const value = assignmentPath.node.right;\n    const isLogicalAssignment = isLogicalOp(op);\n\n    if (superProp.node.computed) {\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      const object = superProp.node.object;\n      const property = superProp.node.property;\n      assignmentPath.get(\"left\").replaceWith(memberExpression(object, assignmentExpression(\"=\", tmp, property), true));\n      assignmentPath.get(\"right\").replaceWith(rightExpression(isLogicalAssignment ? \"=\" : op, memberExpression(object, identifier(tmp.name), true), value));\n    } else {\n      const object = superProp.node.object;\n      const property = superProp.node.property;\n      assignmentPath.get(\"left\").replaceWith(memberExpression(object, property));\n      assignmentPath.get(\"right\").replaceWith(rightExpression(isLogicalAssignment ? \"=\" : op, memberExpression(object, identifier(property.name)), value));\n    }\n\n    if (isLogicalAssignment) {\n      assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right));\n    } else {\n      assignmentPath.node.operator = \"=\";\n    }\n\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    const parts = [assignmentExpression(\"=\", tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression(\"=\", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(superProp.parentPath.node.operator[0], identifier(tmp.name), numericLiteral(1)))];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(sequenceExpression(parts));\n    const left = updateExpr.get(\"expressions.0.right\");\n    const right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n\n  return [superProp];\n\n  function rightExpression(op, left, right) {\n    if (op === \"=\") {\n      return assignmentExpression(\"=\", left, right);\n    } else {\n      return binaryExpression(op, left, right);\n    }\n  }\n}\n\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\n\nconst assignSuperThisVisitor = (0, _visitors.merge)([{\n  CallExpression(child, {\n    supers,\n    thisBinding\n  }) {\n    if (!child.get(\"callee\").isSuper()) return;\n    if (supers.has(child.node)) return;\n    supers.add(child.node);\n    child.replaceWithMultiple([child.node, assignmentExpression(\"=\", identifier(thisBinding), identifier(\"this\"))]);\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();\n    thisEnvFn.traverse(assignSuperThisVisitor, {\n      supers: new WeakSet(),\n      thisBinding\n    });\n  });\n}\n\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));\n  });\n}\n\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  const op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n    let fnBody;\n\n    if (propName) {\n      fnBody = memberExpression(_super(), identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = memberExpression(_super(), identifier(method.name), true);\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = assignmentExpression(\"=\", fnBody, identifier(valueIdent.name));\n    }\n\n    return arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(thisEnvFn, key, init) {\n  const cacheKey = \"binding:\" + key;\n  let data = thisEnvFn.getData(cacheKey);\n\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n\n  return data;\n}\n\nconst getScopeInformationVisitor = (0, _visitors.merge)([{\n  ThisExpression(child, {\n    thisPaths\n  }) {\n    thisPaths.push(child);\n  },\n\n  JSXIdentifier(child, {\n    thisPaths\n  }) {\n    if (child.node.name !== \"this\") return;\n\n    if (!child.parentPath.isJSXMemberExpression({\n      object: child.node\n    }) && !child.parentPath.isJSXOpeningElement({\n      name: child.node\n    })) {\n      return;\n    }\n\n    thisPaths.push(child);\n  },\n\n  CallExpression(child, {\n    superCalls\n  }) {\n    if (child.get(\"callee\").isSuper()) superCalls.push(child);\n  },\n\n  MemberExpression(child, {\n    superProps\n  }) {\n    if (child.get(\"object\").isSuper()) superProps.push(child);\n  },\n\n  Identifier(child, {\n    argumentsPaths\n  }) {\n    if (!child.isReferencedIdentifier({\n      name: \"arguments\"\n    })) return;\n    let curr = child.scope;\n\n    do {\n      if (curr.hasOwnBinding(\"arguments\")) {\n        curr.rename(\"arguments\");\n        return;\n      }\n\n      if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {\n        break;\n      }\n    } while (curr = curr.parent);\n\n    argumentsPaths.push(child);\n  },\n\n  MetaProperty(child, {\n    newTargetPaths\n  }) {\n    if (!child.get(\"meta\").isIdentifier({\n      name: \"new\"\n    })) return;\n    if (!child.get(\"property\").isIdentifier({\n      name: \"target\"\n    })) return;\n    newTargetPaths.push(child);\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nfunction getScopeInformation(fnPath) {\n  const thisPaths = [];\n  const argumentsPaths = [];\n  const newTargetPaths = [];\n  const superProps = [];\n  const superCalls = [];\n  fnPath.traverse(getScopeInformationVisitor, {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  });\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  };\n}"]},"metadata":{},"sourceType":"script"}