{"ast":null,"code":"import { traceSegment, decodedMappings, presortedDecodedMap, TraceMap, encodedMappings } from '@jridgewell/trace-mapping';\n/**\n * A \"leaf\" node in the sourcemap tree, representing an original, unmodified\n * source file. Recursive segment tracing ends at the `OriginalSource`.\n */\n\nclass OriginalSource {\n  constructor(source, content) {\n    this.source = source;\n    this.content = content;\n  }\n  /**\n   * Tracing a `SourceMapSegment` ends when we get to an `OriginalSource`,\n   * meaning this line/column location originated from this source file.\n   */\n\n\n  originalPositionFor(line, column, name) {\n    return {\n      column,\n      line,\n      name,\n      source: this.source,\n      content: this.content\n    };\n  }\n\n}\n/**\n * Puts `key` into the backing array, if it is not already present. Returns\n * the index of the `key` in the backing array.\n */\n\n\nlet put;\n/**\n * FastStringArray acts like a `Set` (allowing only one occurrence of a string\n * `key`), but provides the index of the `key` in the backing array.\n *\n * This is designed to allow synchronizing a second array with the contents of\n * the backing array, like how `sourcesContent[i]` is the source content\n * associated with `source[i]`, and there are never duplicates.\n */\n\nclass FastStringArray {\n  constructor() {\n    this.indexes = Object.create(null);\n    this.array = [];\n  }\n\n}\n\n(() => {\n  put = (strarr, key) => {\n    const {\n      array,\n      indexes\n    } = strarr; // The key may or may not be present. If it is present, it's a number.\n\n    let index = indexes[key]; // If it's not yet present, we need to insert it and track the index in the\n    // indexes.\n\n    if (index === undefined) {\n      index = indexes[key] = array.length;\n      array.push(key);\n    }\n\n    return index;\n  };\n})();\n\nconst INVALID_MAPPING = undefined;\nconst SOURCELESS_MAPPING = null;\n/**\n * traceMappings is only called on the root level SourceMapTree, and begins the process of\n * resolving each mapping in terms of the original source files.\n */\n\nlet traceMappings;\n/**\n * SourceMapTree represents a single sourcemap, with the ability to trace\n * mappings into its child nodes (which may themselves be SourceMapTrees).\n */\n\nclass SourceMapTree {\n  constructor(map, sources) {\n    this.map = map;\n    this.sources = sources;\n  }\n  /**\n   * originalPositionFor is only called on children SourceMapTrees. It recurses down\n   * into its own child SourceMapTrees, until we find the original source map.\n   */\n\n\n  originalPositionFor(line, column, name) {\n    const segment = traceSegment(this.map, line, column); // If we couldn't find a segment, then this doesn't exist in the sourcemap.\n\n    if (segment == null) return INVALID_MAPPING; // 1-length segments only move the current generated column, there's no source information\n    // to gather from it.\n\n    if (segment.length === 1) return SOURCELESS_MAPPING;\n    const source = this.sources[segment[1]];\n    return source.originalPositionFor(segment[2], segment[3], segment.length === 5 ? this.map.names[segment[4]] : name);\n  }\n\n}\n\n(() => {\n  traceMappings = tree => {\n    const mappings = [];\n    const names = new FastStringArray();\n    const sources = new FastStringArray();\n    const sourcesContent = [];\n    const {\n      sources: rootSources,\n      map\n    } = tree;\n    const rootNames = map.names;\n    const rootMappings = decodedMappings(map);\n    let lastLineWithSegment = -1;\n\n    for (let i = 0; i < rootMappings.length; i++) {\n      const segments = rootMappings[i];\n      const tracedSegments = [];\n      let lastSourcesIndex = -1;\n      let lastSourceLine = -1;\n      let lastSourceColumn = -1;\n\n      for (let j = 0; j < segments.length; j++) {\n        const segment = segments[j];\n        let traced = SOURCELESS_MAPPING; // 1-length segments only move the current generated column, there's no source information\n        // to gather from it.\n\n        if (segment.length !== 1) {\n          const source = rootSources[segment[1]];\n          traced = source.originalPositionFor(segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : ''); // If the trace is invalid, then the trace ran into a sourcemap that doesn't contain a\n          // respective segment into an original source.\n\n          if (traced === INVALID_MAPPING) continue;\n        }\n\n        const genCol = segment[0];\n\n        if (traced === SOURCELESS_MAPPING) {\n          if (lastSourcesIndex === -1) {\n            // This is a consecutive source-less segment, which doesn't carry any new information.\n            continue;\n          }\n\n          lastSourcesIndex = lastSourceLine = lastSourceColumn = -1;\n          tracedSegments.push([genCol]);\n          continue;\n        } // So we traced a segment down into its original source file. Now push a\n        // new segment pointing to this location.\n\n\n        const {\n          column,\n          line,\n          name,\n          content,\n          source\n        } = traced; // Store the source location, and ensure we keep sourcesContent up to\n        // date with the sources array.\n\n        const sourcesIndex = put(sources, source);\n        sourcesContent[sourcesIndex] = content;\n\n        if (lastSourcesIndex === sourcesIndex && lastSourceLine === line && lastSourceColumn === column) {\n          // This is a duplicate mapping pointing at the exact same starting point in the source\n          // file. It doesn't carry any new information, and only bloats the sourcemap.\n          continue;\n        }\n\n        lastLineWithSegment = i;\n        lastSourcesIndex = sourcesIndex;\n        lastSourceLine = line;\n        lastSourceColumn = column; // This looks like unnecessary duplication, but it noticeably increases performance. If we\n        // were to push the nameIndex onto length-4 array, v8 would internally allocate 22 slots!\n        // That's 68 wasted bytes! Array literals have the same capacity as their length, saving\n        // memory.\n\n        tracedSegments.push(name ? [genCol, sourcesIndex, line, column, put(names, name)] : [genCol, sourcesIndex, line, column]);\n      }\n\n      mappings.push(tracedSegments);\n    }\n\n    if (mappings.length > lastLineWithSegment + 1) {\n      mappings.length = lastLineWithSegment + 1;\n    }\n\n    return presortedDecodedMap(Object.assign({}, tree.map, {\n      mappings,\n      // TODO: Make all sources relative to the sourceRoot.\n      sourceRoot: undefined,\n      names: names.array,\n      sources: sources.array,\n      sourcesContent\n    }));\n  };\n})();\n\nfunction asArray(value) {\n  if (Array.isArray(value)) return value;\n  return [value];\n}\n/**\n * Recursively builds a tree structure out of sourcemap files, with each node\n * being either an `OriginalSource` \"leaf\" or a `SourceMapTree` composed of\n * `OriginalSource`s and `SourceMapTree`s.\n *\n * Every sourcemap is composed of a collection of source files and mappings\n * into locations of those source files. When we generate a `SourceMapTree` for\n * the sourcemap, we attempt to load each source file's own sourcemap. If it\n * does not have an associated sourcemap, it is considered an original,\n * unmodified source file.\n */\n\n\nfunction buildSourceMapTree(input, loader) {\n  const maps = asArray(input).map(m => new TraceMap(m, ''));\n  const map = maps.pop();\n\n  for (let i = 0; i < maps.length; i++) {\n    if (maps[i].sources.length > 1) {\n      throw new Error(`Transformation map ${i} must have exactly one source file.\\n` + 'Did you specify these with the most recent transformation maps first?');\n    }\n  }\n\n  let tree = build(map, loader, '', 0);\n\n  for (let i = maps.length - 1; i >= 0; i--) {\n    tree = new SourceMapTree(maps[i], [tree]);\n  }\n\n  return tree;\n}\n\nfunction build(map, loader, importer, importerDepth) {\n  const {\n    resolvedSources,\n    sourcesContent\n  } = map;\n  const depth = importerDepth + 1;\n  const children = resolvedSources.map((sourceFile, i) => {\n    // The loading context gives the loader more information about why this file is being loaded\n    // (eg, from which importer). It also allows the loader to override the location of the loaded\n    // sourcemap/original source, or to override the content in the sourcesContent field if it's\n    // an unmodified source file.\n    const ctx = {\n      importer,\n      depth,\n      source: sourceFile || '',\n      content: undefined\n    }; // Use the provided loader callback to retrieve the file's sourcemap.\n    // TODO: We should eventually support async loading of sourcemap files.\n\n    const sourceMap = loader(ctx.source, ctx);\n    const {\n      source,\n      content\n    } = ctx; // If there is no sourcemap, then it is an unmodified source file.\n\n    if (!sourceMap) {\n      // The contents of this unmodified source file can be overridden via the loader context,\n      // allowing it to be explicitly null or a string. If it remains undefined, we fall back to\n      // the importing sourcemap's `sourcesContent` field.\n      const sourceContent = content !== undefined ? content : sourcesContent ? sourcesContent[i] : null;\n      return new OriginalSource(source, sourceContent);\n    } // Else, it's a real sourcemap, and we need to recurse into it to load its\n    // source files.\n\n\n    return build(new TraceMap(sourceMap, source), loader, source, depth);\n  });\n  return new SourceMapTree(map, children);\n}\n/**\n * A SourceMap v3 compatible sourcemap, which only includes fields that were\n * provided to it.\n */\n\n\nclass SourceMap {\n  constructor(map, options) {\n    this.version = 3; // SourceMap spec says this should be first.\n\n    this.file = map.file;\n    this.mappings = options.decodedMappings ? decodedMappings(map) : encodedMappings(map);\n    this.names = map.names;\n    this.sourceRoot = map.sourceRoot;\n    this.sources = map.sources;\n\n    if (!options.excludeContent && 'sourcesContent' in map) {\n      this.sourcesContent = map.sourcesContent;\n    }\n  }\n\n  toString() {\n    return JSON.stringify(this);\n  }\n\n}\n/**\n * Traces through all the mappings in the root sourcemap, through the sources\n * (and their sourcemaps), all the way back to the original source location.\n *\n * `loader` will be called every time we encounter a source file. If it returns\n * a sourcemap, we will recurse into that sourcemap to continue the trace. If\n * it returns a falsey value, that source file is treated as an original,\n * unmodified source file.\n *\n * Pass `excludeContent` to exclude any self-containing source file content\n * from the output sourcemap.\n *\n * Pass `decodedMappings` to receive a SourceMap with decoded (instead of\n * VLQ encoded) mappings.\n */\n\n\nfunction remapping(input, loader, options) {\n  const opts = typeof options === 'object' ? options : {\n    excludeContent: !!options,\n    decodedMappings: false\n  };\n  const tree = buildSourceMapTree(input, loader);\n  return new SourceMap(traceMappings(tree), opts);\n}\n\nexport { remapping as default };","map":{"version":3,"mappings":"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","names":["OriginalSource","constructor","source","content","originalPositionFor","line","column","name","put","FastStringArray","Object","create","strarr","key","array","indexes","index","undefined","length","push","INVALID_MAPPING","SOURCELESS_MAPPING","traceMappings","SourceMapTree","map","sources","segment","traceSegment","names","tree","mappings","sourcesContent","rootSources","rootNames","rootMappings","decodedMappings","lastLineWithSegment","i","segments","tracedSegments","lastSourcesIndex","lastSourceLine","lastSourceColumn","j","traced","genCol","sourcesIndex","presortedDecodedMap","assign","sourceRoot","asArray","value","Array","isArray","buildSourceMapTree","input","loader","maps","m","TraceMap","pop","Error","build","importer","importerDepth","resolvedSources","depth","children","sourceFile","ctx","sourceMap","sourceContent","SourceMap","options","version","file","encodedMappings","excludeContent","toString","JSON","stringify","remapping","opts"],"sources":["../../src/original-source.ts","../../src/fast-string-array.ts","../../src/source-map-tree.ts","../../src/build-source-map-tree.ts","../../src/source-map.ts","../../src/remapping.ts"],"sourcesContent":[null,null,null,null,null,null]},"metadata":{},"sourceType":"module"}