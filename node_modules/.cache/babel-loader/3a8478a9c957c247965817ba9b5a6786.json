{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = simplifyAccess;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  LOGICAL_OPERATORS,\n  assignmentExpression,\n  binaryExpression,\n  cloneNode,\n  identifier,\n  logicalExpression,\n  numericLiteral,\n  sequenceExpression,\n  unaryExpression\n} = _t;\n\nfunction simplifyAccess(path, bindingNames) {\n  let includeUpdateExpression = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  path.traverse(simpleAssignmentVisitor, {\n    scope: path.scope,\n    bindingNames,\n    seen: new WeakSet(),\n    includeUpdateExpression\n  });\n}\n\nconst simpleAssignmentVisitor = {\n  UpdateExpression: {\n    exit(path) {\n      const {\n        scope,\n        bindingNames,\n        includeUpdateExpression\n      } = this;\n\n      if (!includeUpdateExpression) {\n        return;\n      }\n\n      const arg = path.get(\"argument\");\n      if (!arg.isIdentifier()) return;\n      const localName = arg.node.name;\n      if (!bindingNames.has(localName)) return;\n\n      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n        return;\n      }\n\n      if (path.parentPath.isExpressionStatement() && !path.isCompletionRecord()) {\n        const operator = path.node.operator == \"++\" ? \"+=\" : \"-=\";\n        path.replaceWith(assignmentExpression(operator, arg.node, numericLiteral(1)));\n      } else if (path.node.prefix) {\n        path.replaceWith(assignmentExpression(\"=\", identifier(localName), binaryExpression(path.node.operator[0], unaryExpression(\"+\", arg.node), numericLiteral(1))));\n      } else {\n        const old = path.scope.generateUidIdentifierBasedOnNode(arg.node, \"old\");\n        const varName = old.name;\n        path.scope.push({\n          id: old\n        });\n        const binary = binaryExpression(path.node.operator[0], identifier(varName), numericLiteral(1));\n        path.replaceWith(sequenceExpression([assignmentExpression(\"=\", identifier(varName), unaryExpression(\"+\", arg.node)), assignmentExpression(\"=\", cloneNode(arg.node), binary), identifier(varName)]));\n      }\n    }\n\n  },\n  AssignmentExpression: {\n    exit(path) {\n      const {\n        scope,\n        seen,\n        bindingNames\n      } = this;\n      if (path.node.operator === \"=\") return;\n      if (seen.has(path.node)) return;\n      seen.add(path.node);\n      const left = path.get(\"left\");\n      if (!left.isIdentifier()) return;\n      const localName = left.node.name;\n      if (!bindingNames.has(localName)) return;\n\n      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n        return;\n      }\n\n      const operator = path.node.operator.slice(0, -1);\n\n      if (LOGICAL_OPERATORS.includes(operator)) {\n        path.replaceWith(logicalExpression(operator, path.node.left, assignmentExpression(\"=\", cloneNode(path.node.left), path.node.right)));\n      } else {\n        path.node.right = binaryExpression(operator, cloneNode(path.node.left), path.node.right);\n        path.node.operator = \"=\";\n      }\n    }\n\n  }\n};","map":{"version":3,"sources":["/Users/rafaeljordao/Documents/my-portfolio/node_modules/@babel/helper-simple-access/lib/index.js"],"names":["Object","defineProperty","exports","value","default","simplifyAccess","_t","require","LOGICAL_OPERATORS","assignmentExpression","binaryExpression","cloneNode","identifier","logicalExpression","numericLiteral","sequenceExpression","unaryExpression","path","bindingNames","includeUpdateExpression","traverse","simpleAssignmentVisitor","scope","seen","WeakSet","UpdateExpression","exit","arg","get","isIdentifier","localName","node","name","has","getBinding","parentPath","isExpressionStatement","isCompletionRecord","operator","replaceWith","prefix","old","generateUidIdentifierBasedOnNode","varName","push","id","binary","AssignmentExpression","add","left","slice","includes","right"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = simplifyAccess;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  LOGICAL_OPERATORS,\n  assignmentExpression,\n  binaryExpression,\n  cloneNode,\n  identifier,\n  logicalExpression,\n  numericLiteral,\n  sequenceExpression,\n  unaryExpression\n} = _t;\n\nfunction simplifyAccess(path, bindingNames, includeUpdateExpression = true) {\n  path.traverse(simpleAssignmentVisitor, {\n    scope: path.scope,\n    bindingNames,\n    seen: new WeakSet(),\n    includeUpdateExpression\n  });\n}\n\nconst simpleAssignmentVisitor = {\n  UpdateExpression: {\n    exit(path) {\n      const {\n        scope,\n        bindingNames,\n        includeUpdateExpression\n      } = this;\n\n      if (!includeUpdateExpression) {\n        return;\n      }\n\n      const arg = path.get(\"argument\");\n      if (!arg.isIdentifier()) return;\n      const localName = arg.node.name;\n      if (!bindingNames.has(localName)) return;\n\n      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n        return;\n      }\n\n      if (path.parentPath.isExpressionStatement() && !path.isCompletionRecord()) {\n        const operator = path.node.operator == \"++\" ? \"+=\" : \"-=\";\n        path.replaceWith(assignmentExpression(operator, arg.node, numericLiteral(1)));\n      } else if (path.node.prefix) {\n        path.replaceWith(assignmentExpression(\"=\", identifier(localName), binaryExpression(path.node.operator[0], unaryExpression(\"+\", arg.node), numericLiteral(1))));\n      } else {\n        const old = path.scope.generateUidIdentifierBasedOnNode(arg.node, \"old\");\n        const varName = old.name;\n        path.scope.push({\n          id: old\n        });\n        const binary = binaryExpression(path.node.operator[0], identifier(varName), numericLiteral(1));\n        path.replaceWith(sequenceExpression([assignmentExpression(\"=\", identifier(varName), unaryExpression(\"+\", arg.node)), assignmentExpression(\"=\", cloneNode(arg.node), binary), identifier(varName)]));\n      }\n    }\n\n  },\n  AssignmentExpression: {\n    exit(path) {\n      const {\n        scope,\n        seen,\n        bindingNames\n      } = this;\n      if (path.node.operator === \"=\") return;\n      if (seen.has(path.node)) return;\n      seen.add(path.node);\n      const left = path.get(\"left\");\n      if (!left.isIdentifier()) return;\n      const localName = left.node.name;\n      if (!bindingNames.has(localName)) return;\n\n      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n        return;\n      }\n\n      const operator = path.node.operator.slice(0, -1);\n\n      if (LOGICAL_OPERATORS.includes(operator)) {\n        path.replaceWith(logicalExpression(operator, path.node.left, assignmentExpression(\"=\", cloneNode(path.node.left), path.node.right)));\n      } else {\n        path.node.right = binaryExpression(operator, cloneNode(path.node.left), path.node.right);\n        path.node.operator = \"=\";\n      }\n    }\n\n  }\n};"]},"metadata":{},"sourceType":"script"}